#ifndef BYTE_BUFFER_H
#define BYTE_BUFFER_H

#include <vector>

////////////////////////////////////////////////////////////////////////////////
/// \brief ByteBuffer for providing abstraction to working with byte sequences.
///
////////////////////////////////////////////////////////////////////////////////
class ByteBuffer
{
public:
    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Default ByteBuffer constructor.
    ///
    /// Constructs a new ByteBuffer with 0 initial elements in the buffer.
    //////////////////////////////////////////////////////////////////////////////// 
    ByteBuffer();

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief ByteBuffer constructor creating a new buffer of the specified size.
    ///
    /// \param size    The size of the intial buffer to create.
    //////////////////////////////////////////////////////////////////////////////// 
    ByteBuffer(int size);

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief ByteBuffer constructor for building from an existing char vector.
    ///
    /// \param data    The vector to use initialize the ByteBuffer from.
    //////////////////////////////////////////////////////////////////////////////// 
    ByteBuffer(std::vector<unsigned char> data);
    
    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Default ByteBuffer destructor.
    ///
    //////////////////////////////////////////////////////////////////////////////// 
    ~ByteBuffer();
    
    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Overload of the indexing operator.
    ///
    /// Supports indexed access to the underlying ByteBuffer storage. 
    //////////////////////////////////////////////////////////////////////////////// 
    unsigned char operator[](const int index);

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Appends a single byte to the ByteBuffer.
    ///
    /// \param data    The byte to be appended to the ByteBuffer.
    //////////////////////////////////////////////////////////////////////////////// 
    void appendByte(unsigned char data);

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Places a single byte at the beginning of the ByteBuffer.
    ///
    /// \param data    The byte to be placed at the beginning of the ByteBuffer.
    //////////////////////////////////////////////////////////////////////////////// 
    void prependByte(unsigned char data);

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Appends another entire ByteBuffer to this ByteBuffer.
    ///
    /// \param buf     The ByteBuffer to be appended to this ByteBuffer.
    //////////////////////////////////////////////////////////////////////////////// 
    void appendByteBuffer(ByteBuffer buf);

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief View the first byte in the ByteBuffer without altering the contents.
    ///
    //////////////////////////////////////////////////////////////////////////////// 
    unsigned char peekNextByte() const;

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Retrieve and remove the first byte in the ByteBuffer.
    ///
    /// \return The first byte in the ByteBuffer.
    unsigned char removeNextByte();

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Empty out the contents of the ByteBuffer.
    ///
    //////////////////////////////////////////////////////////////////////////////// 
    void clear();

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Get the number of bytes currently in the ByteBuffer.
    ///
    /// \return The number of bytes in the ByteBuffer.
    //////////////////////////////////////////////////////////////////////////////// 
    int getSize() const;

    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Check if the ByteBuffer currently has any bytes stored.
    ///
    /// \return Boolean indicating if the ByteBuffer is empty.
    ////////////////////////////////////////////////////////////////////////////////  
    bool isEmpty() const;
    
    //////////////////////////////////////////////////////////////////////////////// 
    /// \brief Get a pointer to the data stored in the buffer as a char array.
    ///
    /// This function is provided to ease integration with C code that requires
    /// char* values in arguments using the data in the ByteBuffer.  It is not
    /// recommended to use this function for any purpose other than facilitating
    /// such an interface as accidental edits to elements in this array will 
    /// result in changes to the data in the ByteBuffer.
    ///
    /// \return Pointer to a C-style array of the data with char elements.
    //////////////////////////////////////////////////////////////////////////////// 
    const unsigned char* getDataPointer() const;
private:
    std::vector<unsigned char> buffer;
};

#endif
